//https://neetcode.io/problems/count-paths?list=blind75
public class Solution {
    
    // Approach 1: 2D Dynamic Programming - Most intuitive
    public int uniquePaths(int m, int n) {
        // dp[i][j] represents number of unique paths to reach cell (i, j)
        int[][] dp = new int[m][n];
        
        // Initialize first row and first column\n        // There's only one way to reach any cell in first row (keep going right)\n        for (int j = 0; j < n; j++) {\n            dp[0][j] = 1;\n        }\n        \n        // There's only one way to reach any cell in first column (keep going down)\n        for (int i = 0; i < m; i++) {\n            dp[i][0] = 1;\n        }\n        \n        // Fill the rest of the grid\n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                // Number of paths = paths from above + paths from left\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n            }\n        }\n        \n        return dp[m - 1][n - 1];\n    }\n    \n    // Approach 2: Space-optimized DP - O(n) space\n    public int uniquePathsOptimized(int m, int n) {\n        // We only need the previous row to compute current row\n        int[] dp = new int[n];\n        \n        // Initialize first row\n        java.util.Arrays.fill(dp, 1);\n        \n        // Process each row\n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                // dp[j] = dp[j] (from above) + dp[j-1] (from left)\n                dp[j] = dp[j] + dp[j - 1];\n            }\n        }\n        \n        return dp[n - 1];\n    }\n    \n    // Approach 3: Mathematical Combinatorics - O(min(m,n)) time\n    public int uniquePathsMath(int m, int n) {\n        // To reach (m-1, n-1) from (0, 0), we need:\n        // - (m-1) down moves\n        // - (n-1) right moves\n        // Total moves = (m-1) + (n-1) = m + n - 2\n        // We need to choose (m-1) positions for down moves out of (m+n-2) total\n        // Answer = C(m+n-2, m-1) = C(m+n-2, n-1)\n        \n        int totalMoves = m + n - 2;\n        int downMoves = m - 1;\n        \n        // Use the smaller value to minimize computation\n        if (downMoves > totalMoves - downMoves) {\n            downMoves = totalMoves - downMoves;\n        }\n        \n        long result = 1;\n        \n        // Calculate C(totalMoves, downMoves) = totalMoves! / (downMoves! * (totalMoves-downMoves)!)\n        // Optimized calculation to avoid overflow\n        for (int i = 0; i < downMoves; i++) {\n            result = result * (totalMoves - i) / (i + 1);\n        }\n        \n        return (int) result;\n    }\n    \n    // Approach 4: Recursive with Memoization\n    public int uniquePathsRecursive(int m, int n) {\n        int[][] memo = new int[m][n];\n        // Initialize memo with -1 (uncomputed)\n        for (int[] row : memo) {\n            java.util.Arrays.fill(row, -1);\n        }\n        \n        return uniquePathsHelper(m - 1, n - 1, memo);\n    }\n    \n    private int uniquePathsHelper(int i, int j, int[][] memo) {\n        // Base cases\n        if (i == 0 || j == 0) {\n            return 1; // Only one way to reach any cell in first row or column\n        }\n        \n        // Check memoization\n        if (memo[i][j] != -1) {\n            return memo[i][j];\n        }\n        \n        // Recursive relation: paths from above + paths from left\n        memo[i][j] = uniquePathsHelper(i - 1, j, memo) + uniquePathsHelper(i, j - 1, memo);\n        \n        return memo[i][j];\n    }\n    \n    // Approach 5: Bottom-up with minimal space\n    public int uniquePathsMinimalSpace(int m, int n) {\n        // Ensure n is the smaller dimension for space optimization\n        if (m < n) {\n            return uniquePathsMinimalSpace(n, m);\n        }\n        \n        int[] dp = new int[n];\n        java.util.Arrays.fill(dp, 1);\n        \n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                dp[j] += dp[j - 1];\n            }\n        }\n        \n        return dp[n - 1];\n    }\n    \n    // Helper method to demonstrate the DP process\n    public void demonstrateUniquePaths(int m, int n) {\n        System.out.println(\"\\nDemonstrating Unique Paths for \" + m + \"x\" + n + \" grid:\");\n        \n        int[][] dp = new int[m][n];\n        \n        // Initialize borders\n        for (int j = 0; j < n; j++) {\n            dp[0][j] = 1;\n        }\n        for (int i = 0; i < m; i++) {\n            dp[i][0] = 1;\n        }\n        \n        System.out.println(\"After initializing first row and column:\");\n        printGrid(dp);\n        \n        // Fill the grid\n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n                \n                System.out.println(\"\\nCell (\" + i + \",\" + j + \"): \" + \n                                 dp[i - 1][j] + \" (from above) + \" + \n                                 dp[i][j - 1] + \" (from left) = \" + dp[i][j]);\n                printGrid(dp);\n            }\n        }\n        \n        System.out.println(\"\\nFinal result: \" + dp[m - 1][n - 1] + \" unique paths\");\n    }\n    \n    private void printGrid(int[][] grid) {\n        for (int[] row : grid) {\n            System.out.println(java.util.Arrays.toString(row));\n        }\n    }\n    \n    // Method to show the mathematical approach\n    public void demonstrateMathApproach(int m, int n) {\n        System.out.println(\"\\nMathematical Approach for \" + m + \"x\" + n + \" grid:\");\n        \n        int totalMoves = m + n - 2;\n        int downMoves = m - 1;\n        int rightMoves = n - 1;\n        \n        System.out.println(\"To reach (\" + (m-1) + \",\" + (n-1) + \") from (0,0):\");\n        System.out.println(\"- Need \" + downMoves + \" down moves\");\n        System.out.println(\"- Need \" + rightMoves + \" right moves\");\n        System.out.println(\"- Total moves: \" + totalMoves);\n        System.out.println(\"- Problem: Choose \" + downMoves + \" positions out of \" + totalMoves + \" for down moves\");\n        System.out.println(\"- Formula: C(\" + totalMoves + \",\" + downMoves + \") = \" + totalMoves + \"! / (\" + downMoves + \"! * \" + rightMoves + \"!)\");\n        \n        int result = uniquePathsMath(m, n);\n        System.out.println(\"- Result: \" + result);\n    }\n    \n    // Method to compare performance of different approaches\n    public void compareApproaches(int m, int n) {\n        System.out.println(\"\\nComparing approaches for \" + m + \"x\" + n + \" grid:\");\n        \n        // Time each approach\n        long start, end;\n        \n        start = System.nanoTime();\n        int result1 = uniquePaths(m, n);\n        end = System.nanoTime();\n        System.out.println(\"2D DP: \" + result1 + \" (Time: \" + (end - start) + \" ns)\");\n        \n        start = System.nanoTime();\n        int result2 = uniquePathsOptimized(m, n);\n        end = System.nanoTime();\n        System.out.println(\"1D DP: \" + result2 + \" (Time: \" + (end - start) + \" ns)\");\n        \n        start = System.nanoTime();\n        int result3 = uniquePathsMath(m, n);\n        end = System.nanoTime();\n        System.out.println(\"Math: \" + result3 + \" (Time: \" + (end - start) + \" ns)\");\n        \n        start = System.nanoTime();\n        int result4 = uniquePathsRecursive(m, n);\n        end = System.nanoTime();\n        System.out.println(\"Recursive: \" + result4 + \" (Time: \" + (end - start) + \" ns)\");\n        \n        start = System.nanoTime();\n        int result5 = uniquePathsMinimalSpace(m, n);\n        end = System.nanoTime();\n        System.out.println(\"Minimal Space: \" + result5 + \" (Time: \" + (end - start) + \" ns)\");\n    }\n    \n    // Test method\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        int[][] testCases = {\n            {3, 6},\n            {3, 3},\n            {1, 1},\n            {1, 10},\n            {10, 1},\n            {2, 2},\n            {4, 4},\n            {7, 3}\n        };\n        \n        for (int i = 0; i < testCases.length; i++) {\n            int m = testCases[i][0];\n            int n = testCases[i][1];\n            \n            System.out.println(\"\\nTest Case \" + (i + 1) + \": \" + m + \"x\" + n + \" grid\");\n            \n            int result1 = solution.uniquePaths(m, n);\n            int result2 = solution.uniquePathsOptimized(m, n);\n            int result3 = solution.uniquePathsMath(m, n);\n            int result4 = solution.uniquePathsRecursive(m, n);\n            int result5 = solution.uniquePathsMinimalSpace(m, n);\n            \n            System.out.println(\"2D DP: \" + result1);\n            System.out.println(\"1D DP: \" + result2);\n            System.out.println(\"Mathematical: \" + result3);\n            System.out.println(\"Recursive: \" + result4);\n            System.out.println(\"Minimal Space: \" + result5);\n            \n            // Demonstrate process for smaller grids\n            if (m <= 4 && n <= 4) {\n                solution.demonstrateUniquePaths(m, n);\n                solution.demonstrateMathApproach(m, n);\n            }\n            \n            // Performance comparison for larger grids\n            if (m >= 7 || n >= 7) {\n                solution.compareApproaches(m, n);\n            }\n            \n            System.out.println(\"---\");\n        }\n    }\n}
