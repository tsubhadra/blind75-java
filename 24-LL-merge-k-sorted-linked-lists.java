//https://neetcode.io/problems/merge-k-sorted-linked-lists?list=blind75
import java.util.*;

// Definition for singly-linked list
class ListNode {
    int val;
    ListNode next;

    ListNode() {}

    ListNode(int val) {
        this.val = val;
    }

    ListNode(int val, ListNode next) {
        this.val = val;
        this.next = next;
    }
}

public class MergeKSortedLists {

    // SOLUTION 1: Divide and Conquer (Optimal)
    // Time: O(N log k), Space: O(log k) where N = total nodes, k = number of lists
    // Pairs lists and merges them recursively
    public ListNode mergeKLists(ListNode[] lists) {\n        if (lists == null || lists.length == 0) {\n            return null;\n        }\n        \n        return mergeKListsHelper(lists, 0, lists.length - 1);\n    }\n    \n    private ListNode mergeKListsHelper(ListNode[] lists, int start, int end) {\n        // Base case: single list\n        if (start == end) {\n            return lists[start];\n        }\n        \n        // Base case: two lists\n        if (start + 1 == end) {\n            return mergeTwoLists(lists[start], lists[end]);\n        }\n        \n        // Divide: split into two halves\n        int mid = start + (end - start) / 2;\n        ListNode left = mergeKListsHelper(lists, start, mid);\n        ListNode right = mergeKListsHelper(lists, mid + 1, end);\n        \n        // Conquer: merge the two halves\n        return mergeTwoLists(left, right);\n    }\n    \n    // Helper method to merge two sorted lists\n    private ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        ListNode dummy = new ListNode(0);\n        ListNode current = dummy;\n        \n        while (l1 != null && l2 != null) {\n            if (l1.val <= l2.val) {\n                current.next = l1;\n                l1 = l1.next;\n            } else {\n                current.next = l2;\n                l2 = l2.next;\n            }\n            current = current.next;\n        }\n        \n        // Append remaining nodes\n        current.next = (l1 != null) ? l1 : l2;\n        \n        return dummy.next;\n    }\n    \n    // SOLUTION 2: Priority Queue (Min-Heap)\n    // Time: O(N log k), Space: O(k)\n    // Uses a min-heap to always get the smallest element\n    public ListNode mergeKListsPriorityQueue(ListNode[] lists) {\n        if (lists == null || lists.length == 0) {\n            return null;\n        }\n        \n        // Create priority queue with custom comparator\n        PriorityQueue<ListNode> pq = new PriorityQueue<>(\n            (a, b) -> Integer.compare(a.val, b.val)\n        );\n        \n        // Add all non-null head nodes to the priority queue\n        for (ListNode head : lists) {\n            if (head != null) {\n                pq.offer(head);\n            }\n        }\n        \n        ListNode dummy = new ListNode(0);\n        ListNode current = dummy;\n        \n        while (!pq.isEmpty()) {\n            // Get the node with minimum value\n            ListNode minNode = pq.poll();\n            current.next = minNode;\n            current = current.next;\n            \n            // Add the next node from the same list (if exists)\n            if (minNode.next != null) {\n                pq.offer(minNode.next);\n            }\n        }\n        \n        return dummy.next;\n    }\n    \n    // SOLUTION 3: Sequential Merging (Brute Force)\n    // Time: O(N * k), Space: O(1)\n    // Merge lists one by one\n    public ListNode mergeKListsSequential(ListNode[] lists) {\n        if (lists == null || lists.length == 0) {\n            return null;\n        }\n        \n        ListNode result = null;\n        \n        for (ListNode list : lists) {\n            result = mergeTwoLists(result, list);\n        }\n        \n        return result;\n    }\n    \n    // SOLUTION 4: Iterative Divide and Conquer\n    // Time: O(N log k), Space: O(1)\n    // Bottom-up approach without recursion\n    public ListNode mergeKListsIterative(ListNode[] lists) {\n        if (lists == null || lists.length == 0) {\n            return null;\n        }\n        \n        int interval = 1;\n        \n        while (interval < lists.length) {\n            for (int i = 0; i < lists.length - interval; i += interval * 2) {\n                lists[i] = mergeTwoLists(lists[i], lists[i + interval]);\n            }\n            interval *= 2;\n        }\n        \n        return lists[0];\n    }\n    \n    // SOLUTION 5: Using ArrayList and Sorting (Not recommended but simple)\n    // Time: O(N log N), Space: O(N)\n    // Extract all values, sort, and rebuild list\n    public ListNode mergeKListsArraySort(ListNode[] lists) {\n        List<Integer> values = new ArrayList<>();\n        \n        // Extract all values\n        for (ListNode head : lists) {\n            ListNode current = head;\n            while (current != null) {\n                values.add(current.val);\n                current = current.next;\n            }\n        }\n        \n        // Sort values\n        Collections.sort(values);\n        \n        // Rebuild linked list\n        ListNode dummy = new ListNode(0);\n        ListNode current = dummy;\n        \n        for (int val : values) {\n            current.next = new ListNode(val);\n            current = current.next;\n        }\n        \n        return dummy.next;\n    }\n    \n    // SOLUTION 6: Detailed Divide and Conquer with Visualization\n    // Time: O(N log k), Space: O(log k)\n    public ListNode mergeKListsDetailed(ListNode[] lists) {\n        if (lists == null || lists.length == 0) {\n            System.out.println(\"Empty input - returning null\");\n            return null;\n        }\n        \n        System.out.println(\"Starting divide and conquer merge:\");\n        System.out.println(\"Number of lists: \" + lists.length);\n        \n        for (int i = 0; i < lists.length; i++) {\n            System.out.print(\"List \" + i + \": \");\n            printList(lists[i]);\n        }\n        \n        return mergeKListsDetailedHelper(lists, 0, lists.length - 1, 0);\n    }\n    \n    private ListNode mergeKListsDetailedHelper(ListNode[] lists, int start, int end, int depth) {\n        String indent = \"  \".repeat(depth);\n        System.out.printf(\"%sMerging range [%d, %d]\\n\", indent, start, end);\n        \n        if (start == end) {\n            System.out.printf(\"%sBase case: returning list %d\\n\", indent, start);\n            return lists[start];\n        }\n        \n        int mid = start + (end - start) / 2;\n        System.out.printf(\"%sSplitting at mid = %d\\n\", indent, mid);\n        \n        ListNode left = mergeKListsDetailedHelper(lists, start, mid, depth + 1);\n        ListNode right = mergeKListsDetailedHelper(lists, mid + 1, end, depth + 1);\n        \n        System.out.printf(\"%sMerging results from [%d,%d] and [%d,%d]\\n\", \n                         indent, start, mid, mid + 1, end);\n        \n        ListNode merged = mergeTwoLists(left, right);\n        System.out.printf(\"%sMerged result: \", indent);\n        printList(merged);\n        \n        return merged;\n    }\n    \n    // SOLUTION 7: Using Custom Merge with Early Termination\n    // Time: O(N log k), Space: O(log k)\n    // Optimized version that handles null lists efficiently\n    public ListNode mergeKListsOptimized(ListNode[] lists) {\n        if (lists == null || lists.length == 0) {\n            return null;\n        }\n        \n        // Filter out null lists\n        List<ListNode> nonNullLists = new ArrayList<>();\n        for (ListNode list : lists) {\n            if (list != null) {\n                nonNullLists.add(list);\n            }\n        }\n        \n        if (nonNullLists.isEmpty()) {\n            return null;\n        }\n        \n        return mergeKListsHelper(nonNullLists.toArray(new ListNode[0]), 0, nonNullLists.size() - 1);\n    }\n    \n    // Helper methods for testing and visualization\n    \n    // Create linked list from array\n    public ListNode createList(int[] values) {\n        if (values.length == 0) return null;\n        \n        ListNode head = new ListNode(values[0]);\n        ListNode current = head;\n        \n        for (int i = 1; i < values.length; i++) {\n            current.next = new ListNode(values[i]);\n            current = current.next;\n        }\n        \n        return head;\n    }\n    \n    // Print linked list\n    public void printList(ListNode head) {\n        if (head == null) {\n            System.out.println(\"[]\");\n            return;\n        }\n        \n        System.out.print(\"[\");\n        while (head != null) {\n            System.out.print(head.val);\n            if (head.next != null) {\n                System.out.print(\",\");\n            }\n            head = head.next;\n        }\n        System.out.println(\"]\");\n    }\n    \n    // Convert linked list to array for comparison\n    public int[] listToArray(ListNode head) {\n        List<Integer> result = new ArrayList<>();\n        while (head != null) {\n            result.add(head.val);\n            head = head.next;\n        }\n        return result.stream().mapToInt(i -> i).toArray();\n    }\n    \n    // Create array of lists from 2D array\n    public ListNode[] createListArray(int[][] values) {\n        ListNode[] lists = new ListNode[values.length];\n        for (int i = 0; i < values.length; i++) {\n            lists[i] = createList(values[i]);\n        }\n        return lists;\n    }\n    \n    // Test method to verify solutions\n    public static void main(String[] args) {\n        MergeKSortedLists solution = new MergeKSortedLists();\n        \n        // Test case 1: Normal case\n        System.out.println(\"Test Case 1: [[1,2,4],[1,3,5],[3,6]]\");\n        int[][] input1 = {{1,2,4}, {1,3,5}, {3,6}};\n        ListNode[] lists1 = solution.createListArray(input1);\n        \n        System.out.println(\"Input lists:\");\n        for (int i = 0; i < lists1.length; i++) {\n            System.out.print(\"List \" + i + \": \");\n            solution.printList(lists1[i]);\n        }\n        \n        ListNode result1 = solution.mergeKLists(lists1);\n        System.out.print(\"Merged result: \");\n        solution.printList(result1);\n        System.out.println(\"Expected: [1,1,2,3,3,4,5,6]\\n\");\n        \n        // Test case 2: Empty array\n        System.out.println(\"Test Case 2: []\");\n        ListNode[] lists2 = new ListNode[0];\n        ListNode result2 = solution.mergeKLists(lists2);\n        System.out.print(\"Result: \");\n        solution.printList(result2);\n        System.out.println(\"Expected: []\\n\");\n        \n        // Test case 3: Array with empty list\n        System.out.println(\"Test Case 3: [[]]\");\n        ListNode[] lists3 = {null};\n        ListNode result3 = solution.mergeKLists(lists3);\n        System.out.print(\"Result: \");\n        solution.printList(result3);\n        System.out.println(\"Expected: []\\n\");\n        \n        // Test case 4: Single list\n        System.out.println(\"Test Case 4: [[1,2,3]]\");\n        int[][] input4 = {{1,2,3}};\n        ListNode[] lists4 = solution.createListArray(input4);\n        ListNode result4 = solution.mergeKLists(lists4);\n        System.out.print(\"Result: \");\n        solution.printList(result4);\n        System.out.println(\"Expected: [1,2,3]\\n\");\n        \n        // Test case 5: Mixed lengths\n        System.out.println(\"Test Case 5: [[1,4,7],[2,5],[3,6,8,9]]\");\n        int[][] input5 = {{1,4,7}, {2,5}, {3,6,8,9}};\n        ListNode[] lists5 = solution.createListArray(input5);\n        ListNode result5 = solution.mergeKLists(lists5);\n        System.out.print(\"Result: \");\n        solution.printList(result5);\n        System.out.println(\"Expected: [1,2,3,4,5,6,7,8,9]\\n\");\n        \n        // Detailed visualization\n        System.out.println(\"=\" .repeat(60));\n        System.out.println(\"Detailed Divide and Conquer Visualization:\");\n        int[][] input6 = {{1,4}, {2,5}, {3,6}, {7,8}};\n        ListNode[] lists6 = solution.createListArray(input6);\n        solution.mergeKListsDetailed(lists6);\n        \n        // Algorithm comparison\n        System.out.println(\"\\n\" + \"=\".repeat(60));\n        System.out.println(\"Algorithm Comparison: [[1,4,7],[2,5,8],[3,6,9]]\");\n        \n        int[][] testInput = {{1,4,7}, {2,5,8}, {3,6,9}};\n        \n        ListNode[] lists_dc = solution.createListArray(testInput);\n        ListNode result_dc = solution.mergeKLists(lists_dc);\n        System.out.print(\"Divide & Conquer: \");\n        solution.printList(result_dc);\n        \n        ListNode[] lists_pq = solution.createListArray(testInput);\n        ListNode result_pq = solution.mergeKListsPriorityQueue(lists_pq);\n        System.out.print(\"Priority Queue: \");\n        solution.printList(result_pq);\n        \n        ListNode[] lists_seq = solution.createListArray(testInput);\n        ListNode result_seq = solution.mergeKListsSequential(lists_seq);\n        System.out.print(\"Sequential: \");\n        solution.printList(result_seq);\n        \n        ListNode[] lists_iter = solution.createListArray(testInput);\n        ListNode result_iter = solution.mergeKListsIterative(lists_iter);\n        System.out.print(\"Iterative D&C: \");\n        solution.printList(result_iter);\n        \n        System.out.println(\"All should be: [1,2,3,4,5,6,7,8,9]\");\n        \n        // Performance analysis\n        System.out.println(\"\\n\" + \"=\".repeat(60));\n        System.out.println(\"Performance Analysis:\");\n        System.out.println(\"Divide & Conquer: O(N log k) time, O(log k) space - OPTIMAL\");\n        System.out.println(\"Priority Queue: O(N log k) time, O(k) space - Good alternative\");\n        System.out.println(\"Sequential: O(N * k) time, O(1) space - Simple but slow\");\n        System.out.println(\"Iterative D&C: O(N log k) time, O(1) space - Space optimized\");\n        System.out.println(\"Array Sort: O(N log N) time, O(N) space - Not recommended\");\n        System.out.println(\"\\nWhere N = total number of nodes, k = number of lists\");\n        \n        // Edge cases\n        System.out.println(\"\\n\" + \"=\".repeat(60));\n        System.out.println(\"Edge Cases:\");\n        \n        // All empty lists\n        ListNode[] empty_lists = {null, null, null};\n        System.out.print(\"All empty lists: \");\n        solution.printList(solution.mergeKLists(empty_lists));\n        \n        // Single node lists\n        int[][] single_nodes = {{1}, {2}, {3}};\n        ListNode[] single_lists = solution.createListArray(single_nodes);\n        System.out.print(\"Single nodes: \");\n        solution.printList(solution.mergeKLists(single_lists));\n        \n        // Duplicate values\n        int[][] duplicates = {{1,1,2}, {1,2,3}, {2,2,3}};\n        ListNode[] dup_lists = solution.createListArray(duplicates);\n        System.out.print(\"With duplicates: \");\n        solution.printList(solution.mergeKLists(dup_lists));\n    }\n}"