//https://neetcode.io/problems/search-for-word?list=blind75
import java.util.*;

public class WordSearch {

    // SOLUTION 1: Backtracking (Optimal)
    // Time: O(M×N×4^L), Space: O(L) where M,N = board dimensions, L = word length
    // Uses DFS with backtracking to explore all possible paths
    public boolean exist(char[][] board, String word) {\n        if (board == null || board.length == 0 || word == null || word.isEmpty()) {\n            return false;\n        }\n        \n        int rows = board.length;\n        int cols = board[0].length;\n        \n        // Try starting from each cell in the board\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (dfs(board, word, i, j, 0)) {\n                    return true;\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    private boolean dfs(char[][] board, String word, int row, int col, int index) {\n        // Base case: found the complete word\n        if (index == word.length()) {\n            return true;\n        }\n        \n        // Check bounds and character match\n        if (row < 0 || row >= board.length || \n            col < 0 || col >= board[0].length || \n            board[row][col] != word.charAt(index)) {\n            return false;\n        }\n        \n        // Mark current cell as visited by temporarily changing it\n        char temp = board[row][col];\n        board[row][col] = '#';  // Mark as visited\n        \n        // Explore all 4 directions\n        boolean found = dfs(board, word, row + 1, col, index + 1) ||  // Down\n                       dfs(board, word, row - 1, col, index + 1) ||  // Up\n                       dfs(board, word, row, col + 1, index + 1) ||  // Right\n                       dfs(board, word, row, col - 1, index + 1);    // Left\n        \n        // Backtrack: restore the original character\n        board[row][col] = temp;\n        \n        return found;\n    }\n    \n    // SOLUTION 2: Backtracking with Separate Visited Array\n    // Time: O(M×N×4^L), Space: O(M×N + L)\n    // Uses separate boolean array to track visited cells\n    public boolean existWithVisitedArray(char[][] board, String word) {\n        if (board == null || board.length == 0 || word == null || word.isEmpty()) {\n            return false;\n        }\n        \n        int rows = board.length;\n        int cols = board[0].length;\n        boolean[][] visited = new boolean[rows][cols];\n        \n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (dfsWithVisited(board, word, i, j, 0, visited)) {\n                    return true;\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    private boolean dfsWithVisited(char[][] board, String word, int row, int col, \n                                  int index, boolean[][] visited) {\n        if (index == word.length()) {\n            return true;\n        }\n        \n        if (row < 0 || row >= board.length || \n            col < 0 || col >= board[0].length || \n            visited[row][col] || \n            board[row][col] != word.charAt(index)) {\n            return false;\n        }\n        \n        visited[row][col] = true;\n        \n        boolean found = dfsWithVisited(board, word, row + 1, col, index + 1, visited) ||\n                       dfsWithVisited(board, word, row - 1, col, index + 1, visited) ||\n                       dfsWithVisited(board, word, row, col + 1, index + 1, visited) ||\n                       dfsWithVisited(board, word, row, col - 1, index + 1, visited);\n        \n        visited[row][col] = false;  // Backtrack\n        \n        return found;\n    }\n    \n    // SOLUTION 3: Optimized Backtracking with Early Termination\n    // Time: O(M×N×4^L), Space: O(L)\n    // Includes optimizations for better performance\n    public boolean existOptimized(char[][] board, String word) {\n        if (board == null || board.length == 0 || word == null || word.isEmpty()) {\n            return false;\n        }\n        \n        // Optimization: Count character frequencies\n        Map<Character, Integer> boardCount = new HashMap<>();\n        Map<Character, Integer> wordCount = new HashMap<>();\n        \n        // Count characters in board\n        for (char[] row : board) {\n            for (char c : row) {\n                boardCount.put(c, boardCount.getOrDefault(c, 0) + 1);\n            }\n        }\n        \n        // Count characters in word\n        for (char c : word.toCharArray()) {\n            wordCount.put(c, wordCount.getOrDefault(c, 0) + 1);\n        }\n        \n        // Early termination: check if board has enough characters\n        for (Map.Entry<Character, Integer> entry : wordCount.entrySet()) {\n            if (boardCount.getOrDefault(entry.getKey(), 0) < entry.getValue()) {\n                return false;\n            }\n        }\n        \n        // Optimization: reverse word if first char appears more than last char\n        char firstChar = word.charAt(0);\n        char lastChar = word.charAt(word.length() - 1);\n        if (boardCount.getOrDefault(firstChar, 0) > boardCount.getOrDefault(lastChar, 0)) {\n            word = new StringBuilder(word).reverse().toString();\n        }\n        \n        int rows = board.length;\n        int cols = board[0].length;\n        \n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (dfsOptimized(board, word, i, j, 0)) {\n                    return true;\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    private boolean dfsOptimized(char[][] board, String word, int row, int col, int index) {\n        if (index == word.length()) {\n            return true;\n        }\n        \n        if (row < 0 || row >= board.length || \n            col < 0 || col >= board[0].length || \n            board[row][col] != word.charAt(index)) {\n            return false;\n        }\n        \n        char temp = board[row][col];\n        board[row][col] = '#';\n        \n        // Direction vectors for cleaner code\n        int[][] directions = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n        \n        for (int[] dir : directions) {\n            if (dfsOptimized(board, word, row + dir[0], col + dir[1], index + 1)) {\n                board[row][col] = temp;\n                return true;\n            }\n        }\n        \n        board[row][col] = temp;\n        return false;\n    }\n    \n    // SOLUTION 4: Detailed Backtracking with Step Visualization\n    // Time: O(M×N×4^L), Space: O(L)\n    public boolean existDetailed(char[][] board, String word) {\n        System.out.println(\"Searching for word: '\" + word + \"'\");\n        printBoard(board);\n        \n        if (board == null || board.length == 0 || word == null || word.isEmpty()) {\n            return false;\n        }\n        \n        int rows = board.length;\n        int cols = board[0].length;\n        \n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (board[i][j] == word.charAt(0)) {\n                    System.out.printf(\"\\nTrying starting position (%d, %d) with character '%c'\\n\", \n                                    i, j, board[i][j]);\n                    \n                    if (dfsDetailed(board, word, i, j, 0, new ArrayList<>(), 0)) {\n                        return true;\n                    }\n                }\n            }\n        }\n        \n        System.out.println(\"\\nWord not found!\");\n        return false;\n    }\n    \n    private boolean dfsDetailed(char[][] board, String word, int row, int col, \n                               int index, List<String> path, int depth) {\n        String indent = \"  \".repeat(depth);\n        \n        if (index == word.length()) {\n            System.out.println(indent + \"SUCCESS! Found complete word\");\n            System.out.println(indent + \"Path: \" + path);\n            return true;\n        }\n        \n        if (row < 0 || row >= board.length || \n            col < 0 || col >= board[0].length || \n            board[row][col] != word.charAt(index)) {\n            \n            if (row < 0 || row >= board.length || col < 0 || col >= board[0].length) {\n                System.out.println(indent + \"Out of bounds: (\" + row + \", \" + col + \")\");\n            } else {\n                System.out.printf(\"%sCharacter mismatch: expected '%c', found '%c' at (%d, %d)\\n\", \n                                indent, word.charAt(index), board[row][col], row, col);\n            }\n            return false;\n        }\n        \n        // Check if already visited (marked with '#')\n        if (board[row][col] == '#') {\n            System.out.println(indent + \"Already visited: (\" + row + \", \" + col + \")\");\n            return false;\n        }\n        \n        System.out.printf(\"%sMatched '%c' at (%d, %d), looking for index %d\\n\", \n                         indent, board[row][col], row, col, index + 1);\n        \n        char temp = board[row][col];\n        board[row][col] = '#';\n        path.add(\"(\" + row + \",\" + col + \"):\\'\" + temp + \"\\'\");\n        \n        String[] directions = {\"Down\", \"Up\", \"Right\", \"Left\"};\n        int[][] dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n        \n        for (int i = 0; i < 4; i++) {\n            System.out.println(indent + \"Trying \" + directions[i] + \"...\");\n            if (dfsDetailed(board, word, row + dirs[i][0], col + dirs[i][1], \n                           index + 1, path, depth + 1)) {\n                return true;\n            }\n        }\n        \n        System.out.println(indent + \"Backtracking from (\" + row + \", \" + col + \")\");\n        board[row][col] = temp;\n        path.remove(path.size() - 1);\n        \n        return false;\n    }\n    \n    // SOLUTION 5: Iterative DFS using Stack (Alternative approach)\n    // Time: O(M×N×4^L), Space: O(L)\n    public boolean existIterative(char[][] board, String word) {\n        if (board == null || board.length == 0 || word == null || word.isEmpty()) {\n            return false;\n        }\n        \n        int rows = board.length;\n        int cols = board[0].length;\n        \n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (board[i][j] == word.charAt(0)) {\n                    if (dfsIterative(board, word, i, j)) {\n                        return true;\n                    }\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    private boolean dfsIterative(char[][] board, String word, int startRow, int startCol) {\n        Stack<int[]> stack = new Stack<>();\n        stack.push(new int[]{startRow, startCol, 0});  // {row, col, index}\n        \n        char[][] boardCopy = new char[board.length][board[0].length];\n        for (int i = 0; i < board.length; i++) {\n            boardCopy[i] = board[i].clone();\n        }\n        \n        while (!stack.isEmpty()) {\n            int[] current = stack.pop();\n            int row = current[0];\n            int col = current[1];\n            int index = current[2];\n            \n            if (index == word.length()) {\n                return true;\n            }\n            \n            if (row < 0 || row >= board.length || \n                col < 0 || col >= board[0].length || \n                boardCopy[row][col] != word.charAt(index) ||\n                boardCopy[row][col] == '#') {\n                continue;\n            }\n            \n            char temp = boardCopy[row][col];\n            boardCopy[row][col] = '#';\n            \n            // Add neighbors to stack\n            int[][] directions = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n            for (int[] dir : directions) {\n                stack.push(new int[]{row + dir[0], col + dir[1], index + 1});\n            }\n        }\n        \n        return false;\n    }\n    \n    // SOLUTION 6: Trie-based approach (Overkill for single word but shows concept)\n    // Time: O(M×N×4^L), Space: O(ALPHABET_SIZE * L)\n    static class TrieNode {\n        TrieNode[] children = new TrieNode[26];\n        boolean isWord = false;\n        String word = null;\n    }\n    \n    public boolean existTrie(char[][] board, String word) {\n        // Build trie with single word\n        TrieNode root = new TrieNode();\n        buildTrie(root, word);\n        \n        int rows = board.length;\n        int cols = board[0].length;\n        \n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (dfsWithTrie(board, i, j, root)) {\n                    return true;\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    private void buildTrie(TrieNode root, String word) {\n        TrieNode current = root;\n        for (char c : word.toCharArray()) {\n            int index = c - 'A';\n            if (current.children[index] == null) {\n                current.children[index] = new TrieNode();\n            }\n            current = current.children[index];\n        }\n        current.isWord = true;\n        current.word = word;\n    }\n    \n    private boolean dfsWithTrie(char[][] board, int row, int col, TrieNode node) {\n        if (row < 0 || row >= board.length || col < 0 || col >= board[0].length) {\n            return false;\n        }\n        \n        char c = board[row][col];\n        if (c == '#' || node.children[c - 'A'] == null) {\n            return false;\n        }\n        \n        node = node.children[c - 'A'];\n        if (node.isWord) {\n            return true;\n        }\n        \n        board[row][col] = '#';\n        \n        boolean found = dfsWithTrie(board, row + 1, col, node) ||\n                       dfsWithTrie(board, row - 1, col, node) ||\n                       dfsWithTrie(board, row, col + 1, node) ||\n                       dfsWithTrie(board, row, col - 1, node);\n        \n        board[row][col] = c;\n        \n        return found;\n    }\n    \n    // Helper methods for testing and visualization\n    \n    public void printBoard(char[][] board) {\n        System.out.println(\"\\nBoard:\");\n        for (int i = 0; i < board.length; i++) {\n            System.out.print(\"[\");\n            for (int j = 0; j < board[i].length; j++) {\n                System.out.print(\"\\\"\" + board[i][j] + \"\\\"\");\n                if (j < board[i].length - 1) {\n                    System.out.print(\",\");\n                }\n            }\n            System.out.println(\"]\");\n        }\n    }\n    \n    // Test method to verify solutions\n    public static void main(String[] args) {\n        WordSearch solution = new WordSearch();\n        \n        // Test case 1: Word exists\n        System.out.println(\"Test Case 1: CAT\");\n        char[][] board1 = {\n            {'A', 'B', 'C', 'D'},\n            {'S', 'A', 'A', 'T'},\n            {'A', 'C', 'A', 'E'}\n        };\n        \n        boolean result1 = solution.exist(board1, \"CAT\");\n        System.out.println(\"Result: \" + result1);\n        System.out.println(\"Expected: true\\n\");\n        \n        // Test case 2: Word doesn't exist\n        System.out.println(\"Test Case 2: BAT\");\n        char[][] board2 = {\n            {'A', 'B', 'C', 'D'},\n            {'S', 'A', 'A', 'T'},\n            {'A', 'C', 'A', 'E'}\n        };\n        \n        boolean result2 = solution.exist(board2, \"BAT\");\n        System.out.println(\"Result: \" + result2);\n        System.out.println(\"Expected: false\\n\");\n        \n        // Test case 3: Single character\n        System.out.println(\"Test Case 3: A\");\n        char[][] board3 = {{'A'}};\n        boolean result3 = solution.exist(board3, \"A\");\n        System.out.println(\"Result: \" + result3);\n        System.out.println(\"Expected: true\\n\");\n        \n        // Test case 4: Word longer than possible path\n        System.out.println(\"Test Case 4: ABCDEFGH\");\n        char[][] board4 = {\n            {'A', 'B'},\n            {'C', 'D'}\n        };\n        boolean result4 = solution.exist(board4, \"ABCDEFGH\");\n        System.out.println(\"Result: \" + result4);\n        System.out.println(\"Expected: false\\n\");\n        \n        // Test case 5: Complex path\n        System.out.println(\"Test Case 5: ABCCED\");\n        char[][] board5 = {\n            {'A', 'B', 'C', 'E'},\n            {'S', 'F', 'C', 'S'},\n            {'A', 'D', 'E', 'E'}\n        };\n        boolean result5 = solution.exist(board5, \"ABCCED\");\n        System.out.println(\"Result: \" + result5);\n        System.out.println(\"Expected: true\\n\");\n        \n        // Detailed visualization\n        System.out.println(\"=\" .repeat(60));\n        System.out.println(\"Detailed Step-by-Step Example:\");\n        char[][] board6 = {\n            {'C', 'A', 'T'},\n            {'R', 'A', 'E'},\n            {'T', 'S', 'A'}\n        };\n        solution.existDetailed(board6, \"CAT\");\n        \n        // Algorithm comparison\n        System.out.println(\"\\n\" + \"=\".repeat(60));\n        System.out.println(\"Algorithm Verification:\");\n        \n        char[][] testBoard = {\n            {'A', 'B', 'C'},\n            {'D', 'E', 'F'},\n            {'G', 'H', 'I'}\n        };\n        String testWord = \"BEH\";\n        \n        System.out.println(\"Testing word: \" + testWord);\n        System.out.println(\"Backtracking: \" + solution.exist(testBoard, testWord));\n        System.out.println(\"With visited array: \" + solution.existWithVisitedArray(testBoard, testWord));\n        System.out.println(\"Optimized: \" + solution.existOptimized(testBoard, testWord));\n        System.out.println(\"Iterative: \" + solution.existIterative(testBoard, testWord));\n        \n        // Performance analysis\n        System.out.println(\"\\n\" + \"=\".repeat(60));\n        System.out.println(\"Performance Analysis:\");\n        System.out.println(\"Backtracking (optimal): O(M×N×4^L) time, O(L) space - BEST\");\n        System.out.println(\"With visited array: O(M×N×4^L) time, O(M×N + L) space - Clearer\");\n        System.out.println(\"Optimized: O(M×N×4^L) time, O(L) space - With early termination\");\n        System.out.println(\"Iterative: O(M×N×4^L) time, O(L) space - Alternative approach\");\n        System.out.println(\"Trie-based: O(M×N×4^L) time, O(26*L) space - Overkill for single word\");\n        System.out.println(\"\\nWhere M,N = board dimensions, L = word length\");\n        \n        // Edge cases\n        System.out.println(\"\\n\" + \"=\".repeat(60));\n        System.out.println(\"Edge Cases:\");\n        \n        // Empty word\n        System.out.println(\"Empty word: \" + solution.exist(board1, \"\"));\n        \n        // Word with repeated characters\n        char[][] repeatBoard = {\n            {'A', 'A', 'A'},\n            {'A', 'A', 'A'},\n            {'A', 'A', 'A'}\n        };\n        System.out.println(\"Repeated chars (AAAA): \" + solution.exist(repeatBoard, \"AAAA\"));\n        \n        // Single cell board\n        char[][] singleCell = {{'Z'}};\n        System.out.println(\"Single cell (Z): \" + solution.exist(singleCell, \"Z\"));\n        System.out.println(\"Single cell (A): \" + solution.exist(singleCell, \"A\"));\n    }\n}"